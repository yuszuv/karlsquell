#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'fileutils'

$: << File.dirname(__FILE__)

require 'setup'

options = OpenStruct.new
options.limit = 1_000_000

OptionParser.new do |parser|
  parser.banner = <<-EOF
Usage:
  karlsquell <command> [OPTIONS]

Available Commands:
  clean-up-tt-content [-l LIMIT]
    Strip karlsquell specific tags from tt_content's bodytext

  clean-up-sys-history [-l LIMIT]
    Strip karlsquell specific tags from sys_history's history_data

  delete-page-by-fe-group FE_GROUP
    Delete all pages whose fe_group is FE_GROUP, including subtree, tt_content, pages_language_overlay, sys_log, and sys_history entries associated

  delete-tt-content-by-fe-group FE_GROUP
    Delete all tt_content whose fe_group is FE_GROUP, including sys_log and sys_history entries associated

  delete-page-with-subtree UID
    Delete page with uid UID, including subtree, tt_content, pages_language_overlay, sys_log, and sys_history entries associated

  db
    Get a mysql client session
EOF

  parser.separator ""
  parser.separator "Available options:"
  parser.separator ""

  parser.on("-d", "--debug", "Set log level to DEBUG") do ||
    $logger.level = Logger::DEBUG
  end

  parser.on("-h", "--help", "Show this help message") do ||
    puts parser
  end

  parser.on("-l", "--limit LIMIT", Integer, "Limit queries to get at most LIMIT records") do |v|
    options.limit = v
  end
end.parse!

if __FILE__ == $0
  case ARGV[0]
  when "clean-up-tt-content"
    $clean_up_tt_content.call(options.limit)
  when "clean-up-sys-history"
    $clean_up_sys_history.call(options.limit)
  when "delete-page-by-fe-group"
    $delete_page_by_fe_group.call(ARGV[1])
  when "delete-tt-content-by-fe-group"
    $delete_tt_content_by_fe_group.call(ARGV[1])
  when "delete-page-with-subtree"
    $delete_page_with_subtree.call(ARGV[1])
  when "db"
    curr_dir = Dir.pwd
    Dir.chdir(File.dirname(__FILE__))
    system "./db.sh"
    Dir.chdir(curr_dir)   # Restore the original working directory if desired
  end
end

